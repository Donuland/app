/* ========================================
   DONULAND PART 4A - Z√°kladn√≠ kalend√°≈ô (OPRAVEN√Å VERZE)
   Vƒçetnƒõ blacklist a spr√°vn√©ho statusu podle data
   ======================================== */

console.log('üç© Donuland Part 4A FIXED loading...');

// ========================================
// KONTROLA INICIALIZACE
// ========================================

if (typeof window.calendarPart4ALoaded === 'undefined') {
    window.calendarPart4ALoaded = true;
} else {
    console.log('‚ö†Ô∏è Part 4A already loaded, skipping...');
}

// ========================================
// BLACKLIST SYST√âM PRO SMAZAN√â UD√ÅLOSTI
// ========================================

const deletedEventsManager = {
    // Z√≠sk√°n√≠ blacklistu z localStorage
    getDeletedEvents() {
        try {
            return JSON.parse(localStorage.getItem('donuland_deleted_events') || '[]');
        } catch (error) {
            console.warn('Error loading deleted events blacklist:', error);
            return [];
        }
    },
    
    // P≈ôid√°n√≠ ud√°losti do blacklistu
    addToBlacklist(eventId) {
        const deletedEvents = this.getDeletedEvents();
        if (!deletedEvents.includes(eventId)) {
            deletedEvents.push(eventId);
            localStorage.setItem('donuland_deleted_events', JSON.stringify(deletedEvents));
            console.log(`üóëÔ∏è Added to blacklist: ${eventId}`);
        }
    },
    
    // Kontrola, zda je ud√°lost v blacklistu
    isDeleted(eventId) {
        return this.getDeletedEvents().includes(eventId);
    },
    
    // Odstranƒõn√≠ z blacklistu (pro p≈ô√≠pad pot≈ôeby obnoven√≠)
    removeFromBlacklist(eventId) {
        const deletedEvents = this.getDeletedEvents();
        const index = deletedEvents.indexOf(eventId);
        if (index > -1) {
            deletedEvents.splice(index, 1);
            localStorage.setItem('donuland_deleted_events', JSON.stringify(deletedEvents));
            console.log(`‚ôªÔ∏è Removed from blacklist: ${eventId}`);
        }
    }
};

// ========================================
// GLOB√ÅLN√ç STAV KALEND√Å≈òE
// ========================================

const calendarState = {
    currentMonth: new Date().getMonth(),
    currentYear: new Date().getFullYear(),
    events: [],
    isInitialized: false
};

// Paleta barev pro ud√°losti
const EVENT_COLORS = [
    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', 
    '#ff9ff3', '#feca57', '#ff7675', '#74b9ff', '#a29bfe', '#fd79a8'
];

let eventColorIndex = 0;

// ========================================
// UTILITY FUNKCE
// ========================================

// Parsov√°n√≠ data z r≈Øzn√Ωch form√°t≈Ø
function parseDate(dateStr) {
    if (!dateStr) return null;
    if (dateStr instanceof Date) return dateStr;
    
    // YYYY-MM-DD form√°t
    if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
        return new Date(dateStr + 'T12:00:00');
    }
    
    // DD.MM.YYYY form√°t
    if (dateStr.match(/^\d{1,2}\.\d{1,2}\.\d{4}$/)) {
        const [day, month, year] = dateStr.split('.');
        return new Date(year, month - 1, day, 12, 0, 0);
    }
    
    return new Date(dateStr);
}

// Form√°tov√°n√≠ data na YYYY-MM-DD
function formatDateKey(date) {
    if (!date) return '';
    return date.getFullYear() + '-' + 
           String(date.getMonth() + 1).padStart(2, '0') + '-' + 
           String(date.getDate()).padStart(2, '0');
}

// Z√≠sk√°n√≠ unik√°tn√≠ barvy pro ud√°lost
function getUniqueEventColor() {
    const color = EVENT_COLORS[eventColorIndex % EVENT_COLORS.length];
    eventColorIndex++;
    return color;
}

// Normalizace n√°zvu ud√°losti pro porovn√°n√≠
function normalizeEventName(name) {
    if (!name) return '';
    return name.toLowerCase()
        .replace(/[^\w\s]/g, '') // Odstranit speci√°ln√≠ znaky
        .replace(/\s+/g, ' ')    // Normalizovat mezery
        .trim();
}

// Kontrola p≈ôekr√Ωv√°n√≠ datum≈Ø
function datesOverlap(start1, end1, start2, end2) {
    return start1 <= end2 && start2 <= end1;
}

// NOV√â: Urƒçen√≠ statusu ud√°losti podle data
function determineEventStatus(endDate) {
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Nastavit na zaƒç√°tek dne
    
    const eventEnd = new Date(endDate);
    eventEnd.setHours(23, 59, 59, 999); // Nastavit na konec dne ud√°losti
    
    if (eventEnd < today) {
        return 'completed'; // Akce skonƒçila
    } else if (eventEnd.toDateString() === today.toDateString()) {
        return 'ongoing'; // Akce prob√≠h√° dnes
    } else {
        return 'planned'; // Akce je v budoucnu
    }
}

// ========================================
// NAƒå√çT√ÅN√ç A SLUƒåOV√ÅN√ç UD√ÅLOST√ç
// ========================================

// Hlavn√≠ funkce pro naƒçten√≠ v≈°ech ud√°lost√≠
function loadCalendarEvents() {
    console.log('üìÖ Loading calendar events...');
    
    calendarState.events = [];
    
    // 1. Naƒç√≠st historick√° data ze globalState
    loadHistoricalEvents();
    
    // 2. Naƒç√≠st ulo≈æen√© predikce z localStorage
    loadSavedPredictions();
    
    // 3. Naƒç√≠st aktu√°ln√≠ predikci pokud existuje
    loadCurrentPrediction();
    
    // 4. NOV√â: Filtrovat smazan√© ud√°losti pomoc√≠ blacklistu
    filterDeletedEvents();
    
    console.log(`‚úÖ Loaded ${calendarState.events.length} total events (after blacklist filtering)`);
    
    // Emit event pro ostatn√≠ komponenty
    if (typeof eventBus !== 'undefined') {
        eventBus.emit('calendarEventsLoaded', {
            count: calendarState.events.length,
            events: calendarState.events
        });
    }
}

// NOV√â: Filtrov√°n√≠ smazan√Ωch ud√°lost√≠
function filterDeletedEvents() {
    const deletedIds = deletedEventsManager.getDeletedEvents();
    const originalCount = calendarState.events.length;
    
    calendarState.events = calendarState.events.filter(event => {
        const isDeleted = deletedIds.includes(event.id);
        if (isDeleted) {
            console.log(`üóëÔ∏è Filtering out deleted event: ${event.title} (${event.id})`);
        }
        return !isDeleted;
    });
    
    const filteredCount = originalCount - calendarState.events.length;
    if (filteredCount > 0) {
        console.log(`üóëÔ∏è Filtered out ${filteredCount} deleted events from blacklist`);
    }
}

// Naƒçten√≠ historick√Ωch dat ze globalState
function loadHistoricalEvents() {
    if (typeof globalState === 'undefined' || !globalState.historicalData) {
        console.log('üìä No historical data available');
        return;
    }
    
    console.log(`üìä Loading ${globalState.historicalData.length} historical events`);
    
    globalState.historicalData.forEach(record => {
        try {
            const startDate = parseDate(record.dateFrom);
            const endDate = parseDate(record.dateTo || record.dateFrom);
            
            if (!startDate) return;
            
            // OPRAVENO: Status podle data, ne pevnƒõ "completed"
            const status = determineEventStatus(endDate);
            
            const event = {
                id: `historical_${record.rowIndex || Date.now()}_${Math.random()}`,
                title: record.eventName || 'Historick√° akce',
                startDate: startDate,
                endDate: endDate,
                category: record.category || 'ostatn√≠',
                city: record.city || '',
                status: status, // OPRAVENO: Dynamick√Ω status
                source: 'historical',
                color: getUniqueEventColor(),
                hasRealData: true,
                hasPrediction: false,
                data: {
                    visitors: record.visitors || 0,
                    sales: record.sales || 0,
                    weather: record.weather || '',
                    competition: record.competition || 2,
                    rating: record.rating || 0,
                    notes: record.notes || '',
                    businessModel: record.businessModel || '',
                    price: record.price || 110
                }
            };
            
            calendarState.events.push(event);
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Error processing historical record:', error, record);
        }
    });
}

// Naƒçten√≠ ulo≈æen√Ωch predikc√≠ z localStorage
function loadSavedPredictions() {
    try {
        const savedPredictions = JSON.parse(localStorage.getItem('donuland_predictions') || '[]');
        console.log(`üíæ Loading ${savedPredictions.length} saved predictions`);
        
        savedPredictions.forEach((prediction, index) => {
            try {
                const formData = prediction.formData;
                if (!formData || !formData.eventName) return;
                
                const startDate = parseDate(formData.eventDateFrom);
                const endDate = parseDate(formData.eventDateTo);
                
                if (!startDate) return;
                
                const predictionId = `prediction_${index}`;
                
                // Pokusit se slouƒçit s existuj√≠c√≠ historickou akc√≠
                const merged = tryMergeWithHistoricalEvent(prediction, predictionId);
                
                if (!merged) {
                    // Vytvo≈ôit novou predikƒçn√≠ akci
                    createPredictionEvent(prediction, predictionId, startDate, endDate);
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error processing saved prediction:', error, prediction);
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error loading saved predictions:', error);
    }
}

// Naƒçten√≠ aktu√°ln√≠ predikce z globalState
function loadCurrentPrediction() {
    if (typeof globalState === 'undefined' || !globalState.lastPrediction) {
        return;
    }
    
    console.log('ü§ñ Loading current prediction');
    
    try {
        const prediction = globalState.lastPrediction;
        const formData = prediction.formData;
        
        if (!formData || !formData.eventName) return;
        
        const startDate = parseDate(formData.eventDateFrom);
        const endDate = parseDate(formData.eventDateTo);
        
        if (!startDate) return;
        
        const predictionId = 'current_prediction';
        
        // Pokusit se slouƒçit s existuj√≠c√≠ akc√≠
        const merged = tryMergeWithHistoricalEvent(prediction, predictionId);
        
        if (!merged) {
            // Vytvo≈ôit novou predikƒçn√≠ akci
            createPredictionEvent(prediction, predictionId, startDate, endDate);
        }
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Error processing current prediction:', error);
    }
}

// Pokus o slouƒçen√≠ predikce s historickou akc√≠
function tryMergeWithHistoricalEvent(prediction, predictionId) {
    const formData = prediction.formData;
    const startDate = parseDate(formData.eventDateFrom);
    const endDate = parseDate(formData.eventDateTo);
    
    // Naj√≠t podobnou historickou akci
    const existingEvent = calendarState.events.find(event => {
        if (!event.hasRealData) return false;
        
        const nameMatch = normalizeEventName(event.title) === normalizeEventName(formData.eventName);
        const dateOverlap = datesOverlap(event.startDate, event.endDate, startDate, endDate);
        
        return nameMatch && dateOverlap;
    });
    
    if (existingEvent) {
        console.log(`üîÑ Merging prediction with historical event: ${existingEvent.title}`);
        
        // Slouƒçit data
        existingEvent.hasPrediction = true;
        existingEvent.source = 'merged';
        existingEvent.prediction = {
            id: predictionId,
            predictedSales: prediction.prediction?.predictedSales || 0,
            confidence: prediction.prediction?.confidence || 0,
            expectedRevenue: prediction.businessResults?.revenue || 0,
            expectedProfit: prediction.businessResults?.profit || 0,
            businessModel: formData.businessModel || '',
            createdAt: prediction.timestamp || new Date().toISOString(),
            formData: formData
        };
        
        // Doplnit chybƒõj√≠c√≠ data
        if (!existingEvent.data.visitors && formData.visitors) {
            existingEvent.data.visitors = formData.visitors;
        }
        
        return true; // Slouƒçeno
    }
    
    return false; // Neslouƒçeno
}

// Vytvo≈ôen√≠ nov√© predikƒçn√≠ ud√°losti
function createPredictionEvent(prediction, predictionId, startDate, endDate) {
    const formData = prediction.formData;
    
    // OPRAVENO: Status podle data, ne pevnƒõ "planned"
    const status = determineEventStatus(endDate);
    
    const event = {
        id: predictionId,
        title: formData.eventName || 'Predikce',
        startDate: startDate,
        endDate: endDate,
        category: formData.category || 'ostatn√≠',
        city: formData.city || '',
        status: status, // OPRAVENO: Dynamick√Ω status
        source: 'prediction',
        color: getUniqueEventColor(),
        hasRealData: false,
        hasPrediction: true,
        data: {
            visitors: formData.visitors || 0,
            predictedSales: prediction.prediction?.predictedSales || 0,
            confidence: prediction.prediction?.confidence || 0,
            expectedRevenue: prediction.businessResults?.revenue || 0,
            expectedProfit: prediction.businessResults?.profit || 0,
            businessModel: formData.businessModel || '',
            price: formData.price || 110,
            notes: ''
        },
        prediction: {
            id: predictionId,
            predictedSales: prediction.prediction?.predictedSales || 0,
            confidence: prediction.prediction?.confidence || 0,
            expectedRevenue: prediction.businessResults?.revenue || 0,
            expectedProfit: prediction.businessResults?.profit || 0,
            businessModel: formData.businessModel || '',
            createdAt: prediction.timestamp || new Date().toISOString(),
            formData: formData
        }
    };
    
    calendarState.events.push(event);
    console.log(`‚ûï Created prediction event: ${event.title} (status: ${status})`);
}

// ========================================
// GENEROV√ÅN√ç KALEND√Å≈òE
// ========================================

// Aktualizace zobrazen√≠ aktu√°ln√≠ho mƒõs√≠ce
function updateCurrentMonthDisplay() {
    const monthNames = [
        'Leden', '√önor', 'B≈ôezen', 'Duben', 'Kvƒõten', 'ƒåerven',
        'ƒåervenec', 'Srpen', 'Z√°≈ô√≠', '≈ò√≠jen', 'Listopad', 'Prosinec'
    ];
    
    const currentMonthElement = document.getElementById('currentMonth');
    if (currentMonthElement) {
        currentMonthElement.textContent = `${monthNames[calendarState.currentMonth]} ${calendarState.currentYear}`;
    }
}

// Generov√°n√≠ kalend√°≈ôov√© m≈ô√≠≈æky
function generateCalendarGrid() {
    const calendarGrid = document.getElementById('calendarGrid');
    if (!calendarGrid) {
        console.log('‚ùå Calendar grid element not found');
        return;
    }
    
    calendarGrid.innerHTML = '';
    
    // Hlaviƒçka s n√°zvy dn≈Ø
    const dayNames = ['Po', '√öt', 'St', 'ƒåt', 'P√°', 'So', 'Ne'];
    dayNames.forEach(dayName => {
        const header = document.createElement('div');
        header.className = 'calendar-header';
        header.textContent = dayName;
        calendarGrid.appendChild(header);
    });
    
    // Prvn√≠ den mƒõs√≠ce
    const firstDay = new Date(calendarState.currentYear, calendarState.currentMonth, 1);
    const lastDay = new Date(calendarState.currentYear, calendarState.currentMonth + 1, 0);
    const daysInMonth = lastDay.getDate();
    
    // Kolik pr√°zdn√Ωch bunƒõk na zaƒç√°tku (pondƒõl√≠ = 0)
    let startEmpty = firstDay.getDay() - 1;
    if (startEmpty < 0) startEmpty = 6; // Nedƒõle
    
    // P≈ôedchoz√≠ mƒõs√≠c
    const prevMonth = new Date(calendarState.currentYear, calendarState.currentMonth, 0);
    for (let i = startEmpty - 1; i >= 0; i--) {
        const dayNumber = prevMonth.getDate() - i;
        const dayCell = createDayCell(dayNumber, true, calendarState.currentMonth - 1);
        calendarGrid.appendChild(dayCell);
    }
    
    // Aktu√°ln√≠ mƒõs√≠c
    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = createDayCell(day, false, calendarState.currentMonth);
        calendarGrid.appendChild(dayCell);
    }
    
    // N√°sleduj√≠c√≠ mƒõs√≠c (do 42 bunƒõk)
    const totalCells = calendarGrid.children.length - 7; // -7 pro hlaviƒçku
    const remainingCells = 42 - totalCells;
    for (let day = 1; day <= remainingCells; day++) {
        const dayCell = createDayCell(day, true, calendarState.currentMonth + 1);
        calendarGrid.appendChild(dayCell);
    }
    
    displayEventsInCalendar();
}

// Vytvo≈ôen√≠ bu≈àky dne
function createDayCell(dayNumber, isOtherMonth, month) {
    const dayCell = document.createElement('div');
    dayCell.className = 'calendar-day';
    
    if (isOtherMonth) {
        dayCell.classList.add('other-month');
    }
    
    // Datum bu≈àky
    const cellDate = new Date(calendarState.currentYear, month, dayNumber);
    const dateKey = formatDateKey(cellDate);
    dayCell.dataset.date = dateKey;
    
    // Dnes
    const today = new Date();
    if (formatDateKey(cellDate) === formatDateKey(today)) {
        dayCell.classList.add('today');
    }
    
    // ƒå√≠slo dne
    const dayNumberEl = document.createElement('div');
    dayNumberEl.className = 'day-number';
    dayNumberEl.textContent = dayNumber;
    dayCell.appendChild(dayNumberEl);
    
    // Kontejner pro ud√°losti
    const eventsContainer = document.createElement('div');
    eventsContainer.className = 'day-events';
    dayCell.appendChild(eventsContainer);
    
    // Klik na den
    dayCell.addEventListener('click', () => {
        showDayModal(cellDate);
    });
    
    return dayCell;
}

// Zobrazen√≠ ud√°lost√≠ v kalend√°≈ôi
function displayEventsInCalendar() {
    // Vyƒçi≈°tƒõn√≠ v≈°ech ud√°lost√≠
    document.querySelectorAll('.day-events').forEach(container => {
        container.innerHTML = '';
    });
    
    document.querySelectorAll('.calendar-day').forEach(day => {
        day.classList.remove('has-events');
    });
    
    // Seskupen√≠ ud√°lost√≠ podle datum≈Ø
    const eventsByDate = {};
    
    calendarState.events.forEach(event => {
        const startDate = event.startDate;
        const endDate = event.endDate;
        
        // Pro v√≠cedenn√≠ ud√°losti
        const currentDate = new Date(startDate);
        while (currentDate <= endDate) {
            const dateKey = formatDateKey(currentDate);
            
            if (!eventsByDate[dateKey]) {
                eventsByDate[dateKey] = [];
            }
            
            eventsByDate[dateKey].push(event);
            currentDate.setDate(currentDate.getDate() + 1);
        }
    });
    
    // Zobrazen√≠ v kalend√°≈ôi
    Object.entries(eventsByDate).forEach(([dateKey, events]) => {
        const dayCell = document.querySelector(`[data-date="${dateKey}"]`);
        if (!dayCell) return;
        
        const eventsContainer = dayCell.querySelector('.day-events');
        if (!eventsContainer) return;
        
        dayCell.classList.add('has-events');
        
        // Zobrazit max 3 ud√°losti + poƒçet zb√Ωvaj√≠c√≠ch
        const visibleEvents = events.slice(0, 3);
        const hiddenCount = events.length - visibleEvents.length;
        
        visibleEvents.forEach(event => {
            const eventElement = document.createElement('div');
            eventElement.className = 'event-item';
            eventElement.style.backgroundColor = event.color;
            eventElement.style.color = '#fff';
            
            // OPRAVENO: Prefix podle statusu a typu
            let prefix = '';
            if (event.status === 'completed') {
                prefix = '‚úÖ ';
            } else if (event.status === 'ongoing') {
                prefix = '‚è∞ ';
            } else {
                prefix = 'üìÖ ';
            }
            
            // Typ dat
            if (event.hasRealData && event.hasPrediction) {
                prefix += 'üîÑ '; // Slouƒçen√©
            } else if (event.hasRealData) {
                prefix += 'üìä '; // Historick√° data
            } else if (event.hasPrediction) {
                prefix += 'ü§ñ '; // Predikce
            }
            
            eventElement.textContent = prefix + event.title;
            eventElement.title = `${event.title} - ${event.city} (${event.status})`;
            
            eventsContainer.appendChild(eventElement);
        });
        
        // Poƒçet dal≈°√≠ch akc√≠
        if (hiddenCount > 0) {
            const moreElement = document.createElement('div');
            moreElement.className = 'event-item more-events';
            moreElement.style.backgroundColor = '#6c757d';
            moreElement.style.color = '#fff';
            moreElement.textContent = `+${hiddenCount} dal≈°√≠`;
            eventsContainer.appendChild(moreElement);
        }
    });
}

// ========================================
// NAVIGACE KALEND√Å≈òE
// ========================================

// Zmƒõna mƒõs√≠ce
function changeMonth(direction) {
    calendarState.currentMonth += direction;
    
    if (calendarState.currentMonth > 11) {
        calendarState.currentMonth = 0;
        calendarState.currentYear++;
    } else if (calendarState.currentMonth < 0) {
        calendarState.currentMonth = 11;
        calendarState.currentYear--;
    }
    
    updateCurrentMonthDisplay();
    generateCalendarGrid();
    
    console.log(`üìÖ Calendar changed to: ${calendarState.currentMonth + 1}/${calendarState.currentYear}`);
}

// P≈ôechod na dne≈°n√≠ mƒõs√≠c
function goToToday() {
    const today = new Date();
    calendarState.currentMonth = today.getMonth();
    calendarState.currentYear = today.getFullYear();
    
    updateCurrentMonthDisplay();
    generateCalendarGrid();
    
    if (typeof showNotification === 'function') {
        showNotification('üìÖ P≈ôe≈°li jste na aktu√°ln√≠ mƒõs√≠c', 'info', 2000);
    }
}

// ========================================
// MODAL FUNKCIONALITA
// ========================================

// Modal se v≈°emi akcemi dan√©ho dne
function showDayModal(date) {
    const dateKey = formatDateKey(date);
    const dayEvents = calendarState.events.filter(event => {
        const startKey = formatDateKey(event.startDate);
        const endKey = formatDateKey(event.endDate);
        return dateKey >= startKey && dateKey <= endKey;
    });
    
    if (dayEvents.length === 0) {
        if (typeof showNotification === 'function') {
            showNotification('üìÖ ≈Ω√°dn√© ud√°losti v tomto dni', 'info', 2000);
        }
        return;
    }
    
    // Vytvo≈ôen√≠ modalu
    const modal = document.createElement('div');
    modal.className = 'modal day-modal';
    modal.style.display = 'flex';
    
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    
    modalContent.innerHTML = `
        <div class="modal-header">
            <h3>üìÖ ${date.toLocaleDateString('cs-CZ', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            })} (${dayEvents.length} akc√≠)</h3>
            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="day-events-list"></div>
        </div>
    `;
    
    const eventsList = modalContent.querySelector('.day-events-list');
    
    dayEvents.forEach(event => {
        const eventItem = document.createElement('div');
        eventItem.className = 'day-event-item';
        eventItem.style.borderLeft = `4px solid ${event.color}`;
        
        // OPRAVENO: Status ikony podle skuteƒçn√©ho statusu
        let statusIcon = 'üìÖ';
        let statusText = 'Napl√°nov√°no';
        
        if (event.status === 'completed') {
            statusIcon = '‚úÖ';
            statusText = 'Dokonƒçeno';
        } else if (event.status === 'ongoing') {
            statusIcon = '‚è∞';
            statusText = 'Prob√≠h√°';
        }
        
        const sourceIcon = event.hasRealData && event.hasPrediction ? 'üîÑ' : 
                          event.hasRealData ? 'üìä' : 'ü§ñ';
        
        eventItem.innerHTML = `
            <div class="event-header">
                <h4>${escapeHtml(event.title)}</h4>
                <div class="event-meta">
                    ${statusIcon} ${statusText} ‚Ä¢ 
                    ${sourceIcon} ${event.hasRealData && event.hasPrediction ? 'Slouƒçen√° akce' : 
                                   event.hasRealData ? 'Historick√° data' : 'Predikce'} ‚Ä¢ 
                    üìç ${escapeHtml(event.city)} ‚Ä¢ üìã ${escapeHtml(event.category)}
                </div>
            </div>
            <div class="event-stats">
                ${event.data.visitors ? `<span>üë• ${formatNumber(event.data.visitors)} n√°v≈°tƒõvn√≠k≈Ø</span>` : ''}
                ${event.data.sales ? `<span>üç© ${formatNumber(event.data.sales)} ks prod√°no</span>` : ''}
                ${event.data.predictedSales ? `<span>üéØ ${formatNumber(event.data.predictedSales)} ks predikce</span>` : ''}
            </div>
            <div class="event-actions">
                <button class="btn btn-detail" onclick="showEventDetail('${event.id}')">üìã Detail</button>
                <button class="btn btn-delete" onclick="deleteEvent('${event.id}')">üóëÔ∏è Smazat</button>
            </div>
        `;
        
        eventsList.appendChild(eventItem);
    });
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Zav≈ôen√≠ modalu
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
    
    const escHandler = (e) => {
        if (e.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', escHandler);
        }
    };
    document.addEventListener('keydown', escHandler);
}

// Detail konkr√©tn√≠ akce
function showEventDetail(eventId) {
    const event = calendarState.events.find(e => e.id === eventId);
    if (!event) return;
    
    // Zav≈ô√≠t p≈ôedchoz√≠ modal
    document.querySelectorAll('.day-modal').forEach(modal => modal.remove());
    
    const modal = document.createElement('div');
    modal.className = 'modal event-detail-modal';
    modal.style.display = 'flex';
    
    // OPRAVENO: Roz≈°√≠≈ôen√Ω detail s informacemi o statusu
    let statusText = event.status === 'completed' ? 'Dokonƒçeno' : 
                    event.status === 'ongoing' ? 'Prob√≠h√°' : 'Napl√°nov√°no';
    let statusColor = event.status === 'completed' ? '#28a745' : 
                     event.status === 'ongoing' ? '#ffc107' : '#17a2b8';
    
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìã ${escapeHtml(event.title)}</h3>
                <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="event-status-info" style="margin-bottom: 20px; padding: 15px; background: ${statusColor}20; border-left: 4px solid ${statusColor}; border-radius: 6px;">
                    <div style="color: ${statusColor}; font-weight: 600; font-size: 1.1em;">
                        Status: ${statusText}
                    </div>
                    <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                        ${event.hasRealData && event.hasPrediction ? 'üîÑ Slouƒçen√° akce (historick√° data + AI predikce)' : 
                          event.hasRealData ? 'üìä Historick√° data ze Sheets' : 'ü§ñ AI predikce'}
                    </div>
                </div>
                
                <div class="event-detail-grid">
                    <div class="detail-item">
                        <label>N√°zev akce:</label>
                        <span>${escapeHtml(event.title)}</span>
                    </div>
                    <div class="detail-item">
                        <label>Kategorie:</label>
                        <span>${escapeHtml(event.category)}</span>
                    </div>
                    <div class="detail-item">
                        <label>Mƒõsto:</label>
                        <span>${escapeHtml(event.city)}</span>
                    </div>
                    <div class="detail-item">
                        <label>Datum:</label>
                        <span>${event.startDate.toLocaleDateString('cs-CZ')} - ${event.endDate.toLocaleDateString('cs-CZ')}</span>
                    </div>
                    ${event.data.visitors ? `
                        <div class="detail-item">
                            <label>N√°v≈°tƒõvn√≠ci:</label>
                            <span>${formatNumber(event.data.visitors)}</span>
                        </div>
                    ` : ''}
                    ${event.data.sales ? `
                        <div class="detail-item">
                            <label>üìä Re√°lnƒõ prod√°no:</label>
                            <span><strong>${formatNumber(event.data.sales)} ks</strong></span>
                        </div>
                    ` : ''}
                    ${event.data.predictedSales ? `
                        <div class="detail-item">
                            <label>ü§ñ Predikce:</label>
                            <span><strong>${formatNumber(event.data.predictedSales)} ks</strong></span>
                        </div>
                    ` : ''}
                    ${event.hasRealData && event.hasPrediction && event.data.sales && event.data.predictedSales ? `
                        <div class="detail-item">
                            <label>üéØ P≈ôesnost AI:</label>
                            <span><strong>${calculatePredictionAccuracy(event.data.predictedSales, event.data.sales)}%</strong></span>
                        </div>
                    ` : ''}
                    <div class="detail-item full-width">
                        <label>Pozn√°mky:</label>
                        <textarea id="eventNotes" rows="3" placeholder="P≈ôidat pozn√°mku k akci...">${escapeHtml(event.data.notes || '')}</textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-save" onclick="saveEventChanges('${event.id}')">üíæ Ulo≈æit zmƒõny</button>
                <button class="btn btn-delete" onclick="deleteEvent('${event.id}')">üóëÔ∏è Smazat akci</button>
                <button class="btn" onclick="this.closest('.modal').remove()">Zav≈ô√≠t</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// NOV√â: V√Ωpoƒçet p≈ôesnosti predikce
function calculatePredictionAccuracy(predicted, actual) {
    if (!predicted || !actual || predicted <= 0 || actual <= 0) {
        return 0;
    }
    const accuracy = 100 - Math.abs((predicted - actual) / actual) * 100;
    return Math.max(0, Math.min(100, Math.round(accuracy)));
}

// Ulo≈æen√≠ zmƒõn akce
function saveEventChanges(eventId) {
    const event = calendarState.events.find(e => e.id === eventId);
    if (!event) return;
    
    const modal = document.querySelector('.event-detail-modal');
    const notesTextarea = modal.querySelector('#eventNotes');
    
    if (notesTextarea) {
        event.data.notes = notesTextarea.value.trim();
        
        // Aktualizovat v localStorage pokud je to predikce
        if (event.hasPrediction && event.prediction.id.startsWith('prediction_')) {
            updatePredictionInStorage(event);
        }
        
        if (typeof showNotification === 'function') {
            showNotification('‚úÖ Zmƒõny ulo≈æeny', 'success', 2000);
        }
        
        modal.remove();
    }
}

// NOV√â: Aktualizace predikce v localStorage
function updatePredictionInStorage(event) {
    try {
        const savedPredictions = JSON.parse(localStorage.getItem('donuland_predictions') || '[]');
        const predictionIndex = parseInt(event.prediction.id.replace('prediction_', ''));
        
        if (savedPredictions[predictionIndex]) {
            savedPredictions[predictionIndex].notes = event.data.notes;
            savedPredictions[predictionIndex].updatedAt = new Date().toISOString();
            localStorage.setItem('donuland_predictions', JSON.stringify(savedPredictions));
        }
    } catch (error) {
        console.error('Error updating prediction in storage:', error);
    }
}

// NOV√â: Smaz√°n√≠ akce s blacklist podporou
function deleteEvent(eventId) {
    const event = calendarState.events.find(e => e.id === eventId);
    if (!event) return;
    
    const confirmMessage = `Opravdu chcete smazat akci "${event.title}"?` +
        (event.hasPrediction ? '\n\nT√≠m se sma≈æe i souvisej√≠c√≠ AI predikce.' : '') +
        (event.hasRealData ? '\n\nHistorick√° data ze Sheets z≈Østanou zachov√°na, ale akce se ji≈æ nebude zobrazovat v kalend√°≈ôi.' : '') +
        '\n\nPozor: Smazan√° akce se ji≈æ neobnov√≠ ani po refresh str√°nky.';
    
    if (!confirm(confirmMessage)) return;
    
    // P≈òIDAT DO BLACKLISTU
    deletedEventsManager.addToBlacklist(eventId);
    
    // Pokud je to slouƒçen√° akce, p≈ôidat do blacklistu i souvisej√≠c√≠ predikci
    if (event.hasPrediction && event.prediction && event.prediction.id !== eventId) {
        deletedEventsManager.addToBlacklist(event.prediction.id);
        console.log(`üóëÔ∏è Also blacklisted related prediction: ${event.prediction.id}`);
    }
    
    // Odstranit z kalend√°≈ôe (aktu√°ln√≠ zobrazen√≠)
    calendarState.events = calendarState.events.filter(e => e.id !== eventId);
    
    // Smazat z localStorage pokud je to predikce
    if (event.hasPrediction && event.prediction.id.startsWith('prediction_')) {
        deletePredictionFromStorage(event.prediction.id);
    }
    
    // Smazat aktu√°ln√≠ predikci z globalState pokud je to current_prediction
    if (eventId === 'current_prediction' && typeof globalState !== 'undefined' && globalState.lastPrediction) {
        globalState.lastPrediction = null;
        console.log('üóëÔ∏è Cleared current prediction from globalState');
    }
    
    // Refresh kalend√°≈ô
    generateCalendarGrid();
    
    // Zav≈ô√≠t modal
    document.querySelector('.event-detail-modal')?.remove();
    document.querySelector('.day-modal')?.remove();
    
    if (typeof showNotification === 'function') {
        showNotification(`üóëÔ∏è Akce "${event.title}" byla trvale smaz√°na`, 'success', 4000);
    }
    
    console.log(`üóëÔ∏è Event permanently deleted and blacklisted: ${event.title} (${eventId})`);
    
    // Emit event pro ostatn√≠ ƒç√°sti syst√©mu
    if (typeof eventBus !== 'undefined') {
        eventBus.emit('eventDeleted', { 
            eventId: eventId, 
            eventTitle: event.title,
            timestamp: Date.now()
        });
    }
}

// NOV√â: Smaz√°n√≠ predikce z localStorage
function deletePredictionFromStorage(predictionId) {
    try {
        const savedPredictions = JSON.parse(localStorage.getItem('donuland_predictions') || '[]');
        const predictionIndex = parseInt(predictionId.replace('prediction_', ''));
        
        if (savedPredictions[predictionIndex]) {
            savedPredictions.splice(predictionIndex, 1);
            localStorage.setItem('donuland_predictions', JSON.stringify(savedPredictions));
            console.log(`‚úÖ Deleted prediction from storage: ${predictionId}`);
        }
    } catch (error) {
        console.error('‚ùå Error deleting prediction from storage:', error);
    }
}

// ========================================
// INICIALIZACE KALEND√Å≈òE
// ========================================

// Hlavn√≠ inicializaƒçn√≠ funkce
function initializeCalendar() {
    console.log('üîß Initializing calendar...');
    
    if (calendarState.isInitialized) {
        console.log('‚ö†Ô∏è Calendar already initialized');
        return;
    }
    
    // Naƒç√≠st ud√°losti
    loadCalendarEvents();
    
    // Generovat kalend√°≈ô
    updateCurrentMonthDisplay();
    generateCalendarGrid();
    
    // Oznaƒçit jako inicializovan√Ω
    calendarState.isInitialized = true;
    
    console.log('‚úÖ Calendar initialized successfully');
}

// ========================================
// EVENT LISTENERS
// ========================================

// Event listenery pro extern√≠ syst√©my
if (typeof eventBus !== 'undefined') {
    
    eventBus.on('dataLoaded', () => {
        console.log('üìä Data loaded, updating calendar');
        setTimeout(() => {
            loadCalendarEvents();
            if (calendarState.isInitialized) {
                generateCalendarGrid();
            }
        }, 500);
    });
    
    eventBus.on('predictionSaved', () => {
        console.log('üíæ Prediction saved, updating calendar');
        setTimeout(() => {
            loadCalendarEvents();
            if (calendarState.isInitialized) {
                generateCalendarGrid();
            }
        }, 500);
    });
    
    eventBus.on('calendarRequested', () => {
        console.log('üìÖ Calendar section requested');
        if (!calendarState.isInitialized) {
            initializeCalendar();
        } else {
            // Refresh kalend√°≈ô
            loadCalendarEvents();
            generateCalendarGrid();
        }
    });
    
    eventBus.on('predictionCalculated', (data) => {
        console.log('ü§ñ New prediction calculated');
        // Aktualizovat current prediction
        setTimeout(() => {
            loadCalendarEvents();
            if (calendarState.isInitialized) {
                generateCalendarGrid();
            }
        }, 100);
    });
}

// DOM ready listener
document.addEventListener('DOMContentLoaded', function() {
    // Mal√© zpo≈ædƒõn√≠ pro naƒçten√≠ ostatn√≠ch komponent
    setTimeout(() => {
        const calendarSection = document.getElementById('calendar');
        if (calendarSection && !calendarState.isInitialized) {
            console.log('üìÖ DOM ready - initializing calendar');
            initializeCalendar();
        }
    }, 2000);
});

// ========================================
// HELPER FUNKCE PRO KOMPATIBILITU
// ========================================

// Helper funkce pro form√°tov√°n√≠ (pokud nejsou definovan√©)
if (typeof formatNumber === 'undefined') {
    function formatNumber(number) {
        if (number === null || number === undefined || isNaN(number)) {
            return '0';
        }
        return new Intl.NumberFormat('cs-CZ').format(Math.round(number));
    }
}

if (typeof formatCurrency === 'undefined') {
    function formatCurrency(amount) {
        if (amount === null || amount === undefined || isNaN(amount)) {
            return '0 Kƒç';
        }
        return new Intl.NumberFormat('cs-CZ', {
            style: 'currency',
            currency: 'CZK',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
        }).format(Math.round(amount));
    }
}

if (typeof escapeHtml === 'undefined') {
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// ========================================
// GLOB√ÅLN√ç EXPORT
// ========================================

// Export funkc√≠ pro HTML onclick handlery
if (typeof window !== 'undefined') {
    window.changeMonth = changeMonth;
    window.goToToday = goToToday;
    window.showEventDetail = showEventDetail;
    window.initializeCalendar = initializeCalendar;
    window.saveEventChanges = saveEventChanges;
    window.deleteEvent = deleteEvent;
    
    // Debug objekt
    window.calendarDebug = {
        state: calendarState,
        loadEvents: loadCalendarEvents,
        generateGrid: generateCalendarGrid,
        events: () => calendarState.events,
        reinitialize: () => {
            calendarState.isInitialized = false;
            initializeCalendar();
        },
        findEvent: (id) => calendarState.events.find(e => e.id === id),
        eventsByType: () => {
            const types = { historical: 0, prediction: 0, merged: 0 };
            calendarState.events.forEach(e => {
                if (e.hasRealData && e.hasPrediction) types.merged++;
                else if (e.hasRealData) types.historical++;
                else if (e.hasPrediction) types.prediction++;
            });
            return types;
        },
        eventsByStatus: () => {
            const statuses = { completed: 0, ongoing: 0, planned: 0 };
            calendarState.events.forEach(e => {
                statuses[e.status]++;
            });
            return statuses;
        },
        blacklist: {
            getAll: () => deletedEventsManager.getDeletedEvents(),
            add: (eventId) => deletedEventsManager.addToBlacklist(eventId),
            remove: (eventId) => deletedEventsManager.removeFromBlacklist(eventId),
            clear: () => {
                localStorage.removeItem('donuland_deleted_events');
                console.log('üßπ Blacklist cleared');
            },
            restore: (eventId) => {
                deletedEventsManager.removeFromBlacklist(eventId);
                loadCalendarEvents();
                generateCalendarGrid();
                console.log(`‚ôªÔ∏è Event restored: ${eventId}`);
            }
        }
    };
}

console.log('‚úÖ Donuland Part 4A FIXED loaded successfully');
console.log('üìÖ Features: Basic calendar, Event loading, Smart merging, Modal details');
console.log('üîÑ Smart merging: Predictions automatically merge with historical events');
console.log('üìä Data sources: Historical data + Saved predictions + Current prediction');
console.log('‚è∞ Status system: completed/ongoing/planned based on current date');
console.log('üóëÔ∏è Blacklist system: Deleted events stay deleted after page refresh');
console.log('üîß Debug: window.calendarDebug available with blacklist management');

// Emit completion event
if (typeof eventBus !== 'undefined') {
    eventBus.emit('part4ALoaded', { 
        timestamp: Date.now(),
        version: '4A-fixed-1.0.0',
        features: [
            'basic-calendar-grid',
            'event-loading-and-merging', 
            'modal-day-view',
            'event-detail-modal',
            'smart-prediction-merging',
            'multiple-data-sources',
            'dynamic-status-by-date',
            'blacklist-deleted-events',
            'persistent-deletion',
            'prediction-accuracy-calculation'
        ]
    });
}
